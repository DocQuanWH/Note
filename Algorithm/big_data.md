# 海量数据处理
指基于海量数据的存储、处理或操作，通常因为数据量过大，导致无法短时间内迅速处理或者无法一次性载入内存。

## 1. 散列分治
大文件散列成小文件（如果文件能直接载入内存，则不需要散列成小文件） -> 小文件通过hash_map统计 -> 堆排序或归并排序进行统计。

## 2. 位图（BitMap）
位图：用一个**bit**位代表**某个元素X**对应的值（value），而键就是该元素。采用bit位为单位存储数据，能有效的节省计算时的存储空间。位图算法需注意一下问题：
1. 一般通过数组的下标来表示元素，数组所对应的值来表示存在或者重复等
2. 在32位系统中，最大能分配的空间为2^32字节大小的空间。测试在VS32位项目中最多分配了1.6G左右的内存：`char* pBitMap = new char[1647483640];`，需注意的是栈上能分配的空间更少，大概为1M左右（栈代码结构限制）

```C++
// 置位操作
void setBit(char* vBitMap, size_t vIndex)
{
	static unsigned ByteSize = 8;

	vBitMap += vIndex / ByteSize;
	*vBitMap |= 0x01 << (vIndex % ByteSize);
}
```

### 例1：排序
需要对范围在[0, 7]的5个(4, 7, 2, 5, 3)无重复元素进行排序，采用位图方法：
1. 开辟8块bit位空间：

| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| --- | --- | --- | --- | --- | --- | --- | --- |

2. 遍历这5个元素，分别放入所对应的位中

| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 |
| --- | --- | --- | --- | --- | --- | --- | --- |

3. 遍历这块内存，将bit位值为1的元素的index输入，即为排序后的数据(2, 3, 4, 5, 7)

### 例2：电话号码统计
**题目描述**：文件中存放大量电话号码（8位数字），统计不同号码的个数。

**解题方案**：8位数字的电话号码，最多可能组成9999,9999的号码，使用`9999,9999bit / (8 * 1024 * 1024) = 11.92`MB空间即可完成电话号码的统计。

### 例3：2.5亿个整数去重：2-BitMap，使用2bit存放数据状态00表示无、01表示有、10表示重复

### 例4：给40亿无符号整数集，查询给定数据是否已经存在中

## 3. Tire树
Tire树，也叫字典树，优点在于最大限度的减小无畏的字符串比较。常用语统计和排序大量字符串的场景，如搜索引擎文本词频统计。它有以下三个特点：
1. 根节点不包含字符
2. 从根节点到某一节点路径上所有的字符串连接起来，即为该节点对应的字符串
3. 每个节点的所有子节点包含的字符都不相同
比如b, abc, abd, bcd, abcd, efg和hii这六个单词构成的Tire树如下：
1. **root**
2. **root->a，root->b，root->e，root->h**
3. **a->b，b->c，e->f，h->i** 
4. .....

### 例子1：10个频繁出现的词
**题目描述**：一个文本中大概有1万行，每行1个词，统计出其中最频繁出现的10个词。

**解题方案**：
1. 用Tire树统计每个词出现的次数，时间复杂度大概为O(nl)，其中l表示单词的平均长度
2. 使用最小堆（大小为10）来对现有频率排序

### 例子2：寻找热门查询
**题目描述**：搜索引擎会通过日志文件把用户每次检索的字符串（1~255Bytes）都记录下来，现加入目前有1000万条记录（不重复的大概300万），统计最频繁查询的10字符串，要求使用的内存不超过1GB。

**解题方案**：
1. 利用Tire树，记录关键字在该查询串出现的次数，如果没有出现则记录为0
2. 使用最小堆（大小为10）来对现有频率排序

## 4. 海量数据处理算法
#### 1. 
