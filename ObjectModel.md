## 对象模型（Object Model）
C++中有以下几种成员（Member）类型：
> * 成员变量类型：静态成员变量（Static）和非静态成员变量（Nonstatic）
> * 成员函数类型：静态成员函数（Static）、非静态成员函数（Nonstatic）和虚函数（Virtual）

考虑如下一维点的类型设计：
```C++
class CPoint
{
public:
	CPoint(int vX = 0);
	virtual ~CPoint();  		// 虚函数

	float x() const;  		// 成员函数（非静态成员函数）
	static unsigned getNumsPoint(); // 静态成员函数
	
private:
	float m_X;  			// 成员变量（非静态成员变量）
	static unsigned m_NumsPoint;  	// 静态成员变量
};
```
类`CPoint`中拥有了所有C++类可能的成员类型，如何设计其对象模型才能降低类带来的管理成本（相对于C）？

### 1. 简单对象模型
简单对象模型设计十分简单，其目的是为了尽量降低C++编译器的设计复杂度。在简单对象模型中，一个Object是一系列Slots，每个Slot指向一个类成员。按照类成员声明顺序，slot依次指向一个类成员。这个对象模型类似于一个指向类成员的指针数组，每个指针指向一个类成员。

![此处需要插入图片](http://xx.com)

### 2. 表格驱动对象模型
基于表格驱动对象模型是把类成员根据其类型的不同划分为两个表：
> * **成员变量表（Data Member Table）**：直接保存成员变量
> * **成员函数表（Member Function Table）**：类似于简单对象模型，保存指向成员函数的指针

**类模型（Class Object）**则直接保存指向这两个表的指针。

![此处需要插入图片](http://xx.com)

### 3. C++对象模型
C++对象模型是由**简单对象模型**派生而来，并且对**内存空间**和**存取时间**做了相关优化。C++对象模型设计如下：
> * **成员变量**：直接存放到**类模型**中
> * **静态成员变量**：存放到**类模型**之外
> * **成员函数和静态成员函数**：存放到**类模型**之外
> * **虚函数**：
> 	1. 每个类（class）维护一个虚函数表（Virtual Function Table，VFT），该表存放这个类的所有虚函数
> 	2. 每个**类模型**存放一个**vptr**指向VFT。**vptr**的设定和重置是由类的构造函数、析构函数和复制拷贝预算符控制。每个类所对应的**type_info**存放在VFT的第一个slot中。
