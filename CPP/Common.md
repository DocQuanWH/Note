## 一些问题

### 1. 字节顺序
字节存储机制主要有两种：
* **大端模式**：低位存放在**高地址**中。符号位为第一个字符，容易判断正负。
* **小端模式（顺序）**：低位存放在**低地址**中。排列方式都一样，容易类型转换。

比如十六进制数字`0x01020304`存放方式：

|类型|0x00ff3304|0x00ff3303|0x00ff3302|0x00ff3301|
|---|---|---|---|---|
|大端|04（低位）|03|02|01|
|小端|01|02|03|04（低位）|

**网络字节顺序（大端）**：按高位到低位顺序存储

**主机字节顺序**：由具体主机确定

### 2. C++构造函数为什么不能是虚函数？
* 设计角度：虚函数对应一个虚函数表，对象通过虚函数表来找到对应的虚函数，但虚函数表是在类调用构造函数的时候创建的。因此如果构造函数是虚函数，这个时候根本没有虚函数表。
* 实际使用：构造函数不应该是虚函数，因为每个使用的对象我们都应该明确他的类型。

### 3. 栈溢出的原因及解决办法
栈的大小一般默认为1M左右，导致栈溢出的常见原因有两个：
* 函数调用层次过深，每调用一次就压一次栈
* 局部变量占用空间太大，如：申请`char array[1024*1024];`失败，但`char array[1024*1000];`成功

解决方法：
* 增加栈内存（ulimit -s 32768）
* 使用堆

### 4. C++的内存分区
* **栈区**：主要存放**函数参数**以及**局部变量**，由系统自动分配释放（栈一般默认大小为1M，参考3）。
* **堆区**：用户分配，通常调用malloc/new手动申请，手动释放
* **全局/静态区**：存放**全局变量、静态变量**，程序结束后由系统释放
* **字符串常量区**：存放**字符串常量**，程序结束后由系统释放
* **代码区**：存放程序的二进制代码

### 5. C++重写（overwrite）
**overwrite**指派生类的函数名**屏蔽**与其同名的基类函数，规则如下：
* 派生类的函数与基类**函数同名**，**参数不同**：派生类函数无论有无**virtual**关键字都会**屏蔽基类同名函数**
* 派生类的函数与基类**函数同名**，**参数相同**：基类函数没有**virtual**（如果有：override），**屏蔽基类同名函数**

### 6. 构造函数和析构函数调用顺序
* **构造函数**：优先调用**基类**构造函数，然后再调用**子类构造函数**
* **析构函数**：与**构造函数**相反

### 7. static，修饰变量，使之具有全局变量的特性，也不会破坏变量的访问范围（局部访问）

### 8. inline是为了取代宏定义（只是简单替换，不涉及类型检查）而出现的，继承了宏定义快速的有点，同时也保证参数的检测
