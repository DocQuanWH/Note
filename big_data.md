# 海量数据处理
指基于海量数据的存储、处理或操作，通常因为数据量过大，导致无法短时间内迅速处理或者无法一次性载入内存。

## 1. 散列分治
大文件散列成小文件（如果文件能直接载入内存，则不需要散列成小文件） -> 小文件通过hash_map统计 -> 堆排序或归并排序进行统计。

## 2. 位图（BitMap）
位图：用一个**bit**位代表**某个元素X**对应的值（value），而键就是该元素。采用bit位为单位存储数据，能有效的节省计算时的存储空间。位图算法需注意一下问题：
1. 一般通过数组的下标来表示元素，数组所对应的值来表示存在或者重复等
2. 在32位系统中，最大能分配的空间为2^32字节大小的空间。测试在VS32位项目中最多分配了1.6G左右的内存：`char* pBitMap = new char[1647483640];`，需注意的是栈上能分配的空间更少，大概为1M左右（栈代码结构限制）

```C++
// 置位操作
void setBit(char* vBitMap, size_t vIndex)
{
	static unsigned ByteSize = 8;

	vBitMap += vIndex / ByteSize;
	*vBitMap |= 0x01 << (vIndex % ByteSize);
}
```

### 例1：排序
需要对范围在[0, 7]的5个(4, 7, 2, 5, 3)无重复元素进行排序，采用位图方法：
1. 开辟8块bit位空间：

| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| --- | --- | --- | --- | --- | --- | --- | --- |

2. 遍历这5个元素，分别放入所对应的位中

| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 |
| --- | --- | --- | --- | --- | --- | --- | --- |

3. 遍历这块内存，将bit位值为1的元素的index输入，即为排序后的数据(2, 3, 4, 5, 7)

### 例2：电话号码统计
**题目描述**：文件中存放大量电话号码（8位数字），统计不同号码的个数。

**解题方案**：8位数字的电话号码，最多可能组成9999,9999的号码，使用`9999,9999bit / (8 * 1024 * 1024) = 11.92`MB空间即可完成电话号码的统计。

### 例3：2.5亿个整数去重：2-BitMap，使用2bit存放数据状态00表示无、01表示有、10表示重复

### 例4：给40亿无符号整数集，查询给定数据是否已经存在中

## 3. Simhash算法

