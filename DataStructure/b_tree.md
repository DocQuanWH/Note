# B树
**B树（B-Tree）**和**红黑树**，**AVL树**一样都是**平衡查找树**，其执行查找、顺序读取、插入和删除操作的**时间复杂度为O(logn)**。由于B树和B树的变种在**降低磁盘I/O操作次数**方面表现优异，常用于设计文件系统和数据库。

使用**阶**来定义B树的节点结构，**阶**表示节点所包含的**子节点最大数量**。比如，一棵**阶为3的B树**，其节点最多存放**2个元素**，最多拥有**3**个子节点。

## 1. 2-3树
**2-3树**相当于**3阶的B树**，其满足如下性质：
* 每个节点包含1个或2个元素（关键字，Key）：
    - 包含**1个元素**的节点最多**2个子节点**
    - 包含**2个元素**的节点最多**3个子节点**
* 所有**叶子节点**都拥有**相同的深度**

### 2-3树插入操作
1. 定位**元素X**应被插入的**叶子节点位置**
2. 如果叶子节点此时包含**元素个数为1**，则**直接**插入到该叶子节点中，结束插入操作
3. 如果叶子节点此时包含**元素个数为2**，则**暂时**插入到该叶子节点中。然后将**中间**的元素**上溯**到其父节点，并将该节点分裂成两个子节点。
4. 重复2和3操作直至根节点，具体操作如下图所示：

![2-3树插入操作](https://github.com/leechengpeng/Note/blob/master/Resources/Images/2_3_tree1.gif)
![2-3树插入操作](https://github.com/leechengpeng/Note/blob/master/Resources/Images/2_3_tree2.gif)

## 2. B树的定义
**2-3树**实际上是一棵阶为3的B树，也是最简单的B树。一棵m阶的B树，满足以下条件：
* 每个节点容纳的子节点大小范围为[m/2（取上整）, m]
* 拥有m个子节点的非叶节点将包含m-1个键值
* 所有叶节点都在**同一层**
* 如果根节点包含子节点，则至少包含2个子节点
* 插入操作同2-3树

假如每个**盘块**正好存放一个**B树的节点BNode**，那么这个**BNode**就表示这个**盘块**，而该**BNode**的子节点指针存放指向另外一块盘块的地址。一般，一个**NTFS盘块**的大小为**4KB**，可以存放大量节点的关键字和子节点指针信息，大大减少了树的深度，从而加快查询速度。每次检索的一个节点，都会进行一次IO，因此，树的高度越低，IO次数就越少，从而检索速度越快。

## 3. B+树
**B+树**是**B树**的变种，**B+树**比**B树**更适合实际应用中操作系统的文件索引和数据库索引，其特点如下：
* 叶子节点的元素个数和阶树相等，
* **非叶节点**仅具有**索引作用**，所有的**记录相关**的信息均存放在**叶节点中**，且可形成链状结构，
* 树的**所有节结点构成一个有序链**表，可以按照关键码排序的次序遍历全部记录




**B+树**和**B树**的却别在于，**B+树**的叶子节点只包含导航信息
* 它将**所有记录**都**存放**到**叶子节点**，内部节点只存放**关键字**和指向子节点的指针，因此其内部结点相对B 树更小，如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
* B+树的遍历更加高效，B树需要通过中序遍历得到排序数列，B+树直接把所有叶子节点串成链表从头到尾访问即可。B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。

## 4. B+树和数据库索引



参考文章: 
1. [B 树、B+ 树、B\* 树](http://www.cnblogs.com/Bob-FD/archive/2012/06/20/2556505.html)
2. [人人都是 DBA（VII）B 树和 B+ 树](http://www.cnblogs.com/gaochundong/p/btree_and_bplustree.html)
